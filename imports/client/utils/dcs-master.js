const e={};let t;e.getWindowName=(()=>t),e.setWindowName=(n=>{e.throwIf(n&&n.length>15,"Window name is limited to 15 characters"),t=n}),e.log=((...e)=>{t&&(e=[`%c${t.padEnd(15," ")} -`,"color:grey",...e]),console.log(...e)}),e.logIndent=((...e)=>{console.log("  ",...e)}),e.logAlign=((...e)=>{t&&(e=["                 ",...e]),console.log(...e)});class n extends Error{constructor(e){super(e),this.name="DocussError"}}e.throwIf=((e,o)=>{if(e)throw t&&(o=`${t} - ${o}`),new n(o)}),e.throwIfNot=((t,n)=>e.throwIf(!t,n)),e.dev={assert:(t,n)=>e.throwIfNot(t,`Assertion Failed${n?" - "+n:""}`),log:e.log,logIndent:e.logIndent,logAlign:e.logAlign};class o{constructor(e){this.name=e,this.silent=!1,this.dev={log:this.log.bind(this),logIndent:this.logIndent.bind(this),logAlign:this.logAlign.bind(this)}}log(...t){this.silent||(this.name&&(t=[`${this.name} -`,...t]),e.log(...t))}logIndent(...t){this.silent||e.logIndent(...t)}logAlign(...t){this.silent||(this.name&&(t=[" ".repeat(this.name.length+2),...t]),e.logAlign(...t))}}e.logger=(e=>new o(e)),e.pick=((e,t)=>e?t.reduce((t,n)=>(e.hasOwnProperty(n)&&(t[n]=e[n]),t),{}):e),e.omit=((e,t)=>e?Object.keys(e).reduce((n,o)=>(t.includes(o)||(n[o]=e[o]),n),{}):e),e.async={delay:e=>new Promise(t=>setTimeout(t,e)),retry:(t,n,o)=>0===n?Promise.reject(o):Promise.resolve(t(o,n)).then(o=>o||e.async.retry(t,n-1,o)),retryDelay(t,n,o,s){const i=n=>e.async.delay(o).then(()=>t(n));return 0===n?Promise.reject(s):Promise.resolve(t(n)).then(t=>t||e.async.retryDelay(i,n-1))},find:(t,n,o=null)=>t&&0!==t.length?Promise.resolve(n(t[0])).then(s=>s?t[0]:e.async.find(t.slice(1),n,o)):Promise.resolve(void 0)};const s={onDOMReady:()=>new Promise(e=>{"loading"!==document.readyState?e():document.addEventListener("DOMContentLoaded",e)}),forEach:function(e,t,n){n=n||window;for(let o=0;o<e.length;o++)t.call(n,e[o],o)},wrapAll:function(e,t){if(e&&e.length){const n=Array.prototype.slice.call(e);n[0].parentNode.insertBefore(t,n[0]),n.forEach(e=>t.appendChild(e))}},elementFromHtml:function(e){const t=document.createElement("div");return t.innerHTML=e.trim(),t.firstChild},inIFrame:()=>{try{return window.self!==window.top}catch(e){return!0}},ajax:function(e,t,n){return new Promise((o,s)=>{var i=new XMLHttpRequest;i.open(e,t,!0),i.setRequestHeader("Content-Type","application/json"),i.onreadystatechange=function(){4===i.readyState&&(200===i.status?o(JSON.parse(i.responseText)):(0!==i.status||i.statusText||s("Cross-domain call failed (see the error message above)"),s({status:i.status,statusText:i.statusText})))},i.send(n?JSON.stringify(n):null)})}},i=null;let r,a=[];class l{constructor({remoteWindow:t,remoteName:n,remoteOrigin:o,timeout:s=1e4,onTimeout:r,logger:a=i}={}){e.throwIfNot(e.getWindowName(),"RemoteWindow needs a window name. Did you forget to call u.setWindowName()?"),this.logger=a,this.handlers=[],this.onConnectedHandlers=[],this.pendingSend=[],this.pendingReceive=[],this.connected=!1,t&&this.initiateConnection({remoteWindow:t,remoteName:n,remoteOrigin:o,timeout:s,onTimeout:r})}initiateConnection({remoteWindow:t,remoteName:n,remoteOrigin:o,timeout:i=1e4,onTimeout:r}){this.remoteWindow=t,this.remoteName=n,this.remoteOrigin=o,this.onConnectedPriority=!1,this.connected=!1,a.forEach(o=>{e.dev.assert(o.remoteName!==n,`Duplicate remoteName "${n}"`),o.remoteWindow===t&&e.dev.log("Warning: same remoteWindow is already targeted by a previous RemoteWindow instance")}),a.push(this),this.pingTimer=null,s.inIFrame()&&(this._postMessage({firstPing:!0}),this.pingTimer=setInterval(()=>{this._postMessage({ping:!0})},300)),this.timeoutTimer=null,i&&(this.timeoutTimer=setTimeout(()=>{const e=`Timeout: couldn't connect to "${n}" after ${i/1e3}s`;this._log(e),clearInterval(this.pingTimer),this.pingTimer=null,r&&r(e)},i))}destroy(){const t=a.length;a=a.filter(e=>e!==this),e.dev.assert(a.length!==t)}isConnected(){return this.connected}onConnected(t,n=!1){e.throwIf(this.onConnectedPriority,"There is already a priority onConnect handler"),n?(this.onConnectedPriority=!0,this.onConnectedHandlers.unshift(t)):this.onConnectedHandlers.push(t)}_log(...e){this.logger&&this.logger.log(...e)}postMessage(e,...t){const n={name:e,args:t};this.connected?this._postMessage(n):this.pendingSend.push(n)}onMessage(e,t){const n=this.pendingReceive.filter(t=>t.name===e);if(this.pendingReceive=this.pendingReceive.filter(t=>t.name!==e),n.length){let o;return n.forEach((e,n)=>{this._log(`Calling handler for postponed message "${e.name}"`);const s=t(...e.args);0===n&&(o=s)}),this.handlers.push({name:e,cb:t}),Promise.resolve(o)}return new Promise((n,o)=>{this.handlers.push({name:e,cb:t,resolve:n})})}_postMessage(t){const n=Object.assign({},t,{from:e.getWindowName(),to:this.remoteName});this._log(`Sending message to ${this.remoteName} (${this.remoteOrigin}):`,e.omit(n,["from","to"]));try{this.remoteWindow.postMessage(n,this.remoteOrigin)}catch(e){throw this._log("Sending message failed. Possible cause: message is not a plain object."),e}}}addEventListener("message",t=>{const n=t.data,o=a.find(e=>e.remoteName===n.from);if(o&&n.to===e.getWindowName())if(o._log(`Received message from ${o.remoteName}:`,e.omit(n,["to","from"])),"*"===o.remoteOrigin||t.origin===o.remoteOrigin){if(clearTimeout(o.timeoutTimer),o.timeoutTimer=null,n.firstPing||n.ping)o._postMessage({stopPing:!0}),n.firstPing&&o.connected&&o.onConnectedHandlers.forEach(e=>e({firstConnect:!1}));else if(n.stopPing)clearInterval(o.pingTimer),o.pingTimer=null;else{const e=o.handlers.filter(e=>"*"===e.name||e.name===n.name);e.length?e.forEach(e=>{const t=e.cb(...n.args);e.resolve&&e.resolve(t)}):(o.pendingReceive.push(n),o._log("No message handler found: storing message for later use."))}o.connected||(o.connected=!0,o.pendingSend.forEach(e=>o._postMessage(e)),o.pendingSend=null,o.onConnectedHandlers.forEach(e=>e({firstConnect:!0})))}else o._log(`Origin mismatch: "${t.origin}" doesn't match ${o.remoteOrigin})`)}),e.setWindowName("dcs-link-layout");const c=[],g=[],d=[],h=[],m=[];let u={topicId:null,tag:null,path:null};const p={connect:({discourseWindow:t,discourseOrigin:n,timeout:o})=>new Promise((s,i)=>{e.dev.assert(!r,"You already called connect()"),(r=new l({remoteName:"dcs-disc-plugin",remoteWindow:t,remoteOrigin:n,timeout:o,onTimeout:e=>i(e)})).onConnected(({firstConnect:e})=>{e?s():u.topicId?p.gotoTopic(u.topicId):u.tag?p.gotoTag(u.tag):u.path?p.gotoPath(u.path):p.gotoHome()}),r.onMessage("pageChange",e=>{if(e.triggeredByRW||e.justLoaded)return;const t=e.dcsTopic&&e.dcsTopic.id||null,n=t?e.dcsTopic.dcsTag:e.dcsTag||null;n?d.forEach(e=>e(n,t)):e.isHome?c.forEach(e=>e()):e.path&&g.forEach(t=>t(e.path))}),r.onMessage("redirect",t=>{e.dev.assert(t),location.href=t}),r.onMessage("userChange",e=>{h.forEach(t=>t(e))}),r.onMessage("dcsTags",e=>{m.forEach(t=>t(e))})}),gotoHome(){e.dev.assert(r,"Call connect() first"),r.postMessage("gotoHome"),u={topicId:null,tag:null,path:null}},gotoTopic(t){e.dev.assert(r,"Call connect() first"),r.postMessage("gotoTopic",t),u={topicId:t,tag:null,path:null}},gotoTag(t){e.dev.assert(r,"Call connect() first"),e.dev.assert(t.startsWith("dcs-"),'Tag must begins with "dcs-"'),e.dev.assert(t.length<=20,"Tag length must be <= 20"),e.dev.assert(t===t.toLowerCase(),"Tag must be lower case"),r.postMessage("gotoTag",t),u={topicId:null,tag:t,path:null}},gotoPath(t){e.dev.assert(r,"Call connect() first"),r.postMessage("gotoPath",t),u={topicId:null,tag:null,path:t}},onHome(t){e.dev.assert(r,"Call connect() first"),c.push(t)},onPath(t){e.dev.assert(r,"Call connect() first"),g.push(t)},onTagOrTopic(t){e.dev.assert(r,"Call connect() first"),d.push(t)},onUserChange(t){e.dev.assert(r,"Call connect() first"),h.push(t)},onDcsTags(t){e.dev.assert(r,"Call connect() first"),m.push(t)}};export{p as dcs};
